<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
	<xsl:output encoding="utf-8" indent="no" method="text"/>
	<xsl:param name="package"/>
	<xsl:template match="/access_info">
		
/**
 *  Autogenerated class
 */
package <xsl:value-of select="$package"/>.access;

import java.sql.SQLException;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import org.c3s.db.access.Access;
import org.c3s.db.*;
import org.c3s.db.beans.*;
import org.c3s.db.injectors.SqlInjectorInterface;
import org.c3s.db.injectors.EmptySqlInjector;
import org.c3s.data.mapers.*;
import org.c3s.data.cast.*;

<!--
<xsl:for-each select="table/bean">import <xsl:value-of select="$package"/>.beans.DB<xsl:value-of select="@name"/>Bean;
</xsl:for-each>
-->
import <xsl:value-of select="$package"/>.beans.*;

<xsl:variable name="class_name">DB<xsl:value-of select="table/bean/@name"/>Access</xsl:variable>
@SuppressWarnings("unused")
public class <xsl:value-of select="$class_name"/> extends Access {
	protected DBConnection getConnection() {
		setNames();
		return getCon();
	}
	
	private DataMapper dataMapper = new GeneralDataMapper(new GeneralCastType()); 
	
	protected void setNames() {
		con_name = "<xsl:value-of select="table/@connection"/>";
		tablename = "<xsl:value-of select="table/@name"/>";
	}
	
	<xsl:variable name="param_type">DB<xsl:value-of select="table/bean[1]/@name"/>Bean</xsl:variable>
	public int insert(<xsl:value-of select="$param_type"/> bean) throws SQLException, IllegalArgumentException, IllegalAccessException {
		setNames();
		int res = _insert(bean);
		bean.setAutoincrementField(res);
		return res;
	}

	<xsl:variable name="ret_type">List&lt;DB<xsl:value-of select="table/bean[1]/@name"/>Bean&gt;</xsl:variable>
	<xsl:variable name="int_type">DB<xsl:value-of select="table/bean[1]/@name"/>Bean</xsl:variable>
	public <xsl:value-of select="$ret_type"/> getTableRecords() throws SQLException, IllegalArgumentException, IllegalAccessException, InstantiationException {
		return getTableRecords(null);
	}
	public <xsl:value-of select="$ret_type"/> getTableRecords(SqlInjectorInterface injector) throws SQLException, IllegalArgumentException, IllegalAccessException, InstantiationException {
		setNames();
		List&lt;Map&lt;String, Object&gt;&gt; result = _getTableRecords(injector);
		
		<xsl:value-of select="$ret_type"/> ret = null;
		if (result != null) {
			ret = new Array<xsl:value-of select="$ret_type"/>();
			for (Map&lt;String, Object&gt; res : result) {
				<xsl:value-of select="$int_type"/> bean = dataMapper.mapFromRow(res, <xsl:value-of select="$int_type"/>.class);
				<xsl:if test="/access_info/table/bean/method[@name='onLoad']">bean.onLoad();</xsl:if>
				ret.add(bean);
			}
		}
		return ret;
	}
	
	<xsl:for-each select="table/select">
		<xsl:call-template name="select"/>
	</xsl:for-each>
	
	<xsl:for-each select="table/update">
		<xsl:call-template name="update"/>
	</xsl:for-each>
	
	<xsl:for-each select="table/delete">
		<xsl:call-template name="delete"/>
	</xsl:for-each>
	
	<xsl:for-each select="table/query">
		<xsl:call-template name="query"/>
	</xsl:for-each>
}
	</xsl:template>
<!--
//
// Selects
//
-->
	<xsl:template name="select">
	<xsl:variable name="ret_type">
		<xsl:choose>
			<xsl:when test="@is_single = 'true'">DB<xsl:value-of select="../bean/@name"/>Bean</xsl:when>
			<xsl:otherwise>List&lt;DB<xsl:value-of select="../bean/@name"/>Bean&gt;</xsl:otherwise>
		</xsl:choose>
	</xsl:variable>
	<xsl:variable name="new_type">
		<xsl:choose>
			<xsl:when test="@is_single = 'true'"><xsl:value-of select="$ret_type"/></xsl:when>
			<xsl:otherwise>Array<xsl:value-of select="$ret_type"/></xsl:otherwise>
		</xsl:choose>
	</xsl:variable>
	<xsl:variable name="int_type">DB<xsl:value-of select="../bean[1]/@name"/>Bean</xsl:variable>
	<xsl:if test="string-length(@intruder) != 0">
	public <xsl:value-of select="$ret_type"/> get<xsl:value-of select="@name"/>(<xsl:call-template name="get_params"/>) throws SQLException, IllegalArgumentException, IllegalAccessException, InstantiationException {
		return get<xsl:value-of select="@name"/>(<xsl:call-template name="get_params_without_type"/><xsl:if test="count(column) != 0">, </xsl:if>null);
	}
	</xsl:if>
	public <xsl:value-of select="$ret_type"/> get<xsl:value-of select="@name"/>(<xsl:call-template name="get_params"/><xsl:if test="string-length(@intruder) != 0"><xsl:if test="count(column) != 0">, </xsl:if><xsl:value-of select="@intruder"/> paramIntruder</xsl:if>)  throws SQLException, IllegalArgumentException, IllegalAccessException, InstantiationException {
		setNames();
		<xsl:value-of select="$ret_type"/> ret = null;
		SqlInjectorInterface injector = new EmptySqlInjector();
		<xsl:if test="string-length(@intruder) != 0">
		if (paramIntruder != null) {
			injector = paramIntruder;
		}
		</xsl:if>
		String sql = "SELECT t.* "+injector.getRecordQuery()+" FROM " + tablename + " as t "+injector.getFromQuery()+" WHERE 1=1 <xsl:call-template name="get_sql_params"/> "+injector.getWhereQuery()+" ";
		if (injector.getOrderQuery().length() != 0) {
			sql += injector.getOrderQuery();
		} else { 
			<xsl:if test="string-length(sort) != 0">sql += "ORDER BY <xsl:value-of select="sort"/>";
			</xsl:if>
		}
		sql += injector.getLimitQuery();
		List&lt;Map&lt;String, Object&gt;&gt; result = getConnection().fetchRows(tablename + ".get<xsl:value-of select="@name"/>", sql <xsl:call-template name="get_fetch_params"/>);
		if (result != null) {
			<xsl:choose>
				<xsl:when test="@is_single = 'true'">
			ret = dataMapper.mapFromRow(result.get(0), <xsl:value-of select="$int_type"/>.class);
			<xsl:if test="/access_info/table/bean/method[@name='onLoad']">ret.onLoad();</xsl:if>
			<xsl:if test="table/bean/method[@name='onLoad']">ret.onLoad();</xsl:if>
				</xsl:when>
				<xsl:otherwise>
			ret = new <xsl:value-of select="$new_type"/>();
			for (Map&lt;String, Object&gt; res : result) {
				<xsl:value-of select="$int_type"/> bean = dataMapper.mapFromRow(res, <xsl:value-of select="$int_type"/>.class);
				<xsl:if test="/access_info/table/bean/method[@name='onLoad']">bean.onLoad();</xsl:if> 
				ret.add(bean);
			}
				</xsl:otherwise>
			</xsl:choose>
		}
		return ret;
	}
	</xsl:template>
<!--
//
// Common Parameters
//
-->
	<xsl:template name="get_params">
		<xsl:for-each select="column[@omitted='true']"><xsl:if test="position() != 1">, </xsl:if><xsl:value-of select="@type"/> param<xsl:value-of select="@param_name"/></xsl:for-each>
	</xsl:template>
	<xsl:template name="get_params_for_update">
		<xsl:for-each select="column[@omitted='true']">, <xsl:value-of select="@type"/> param<xsl:value-of select="@param_name"/></xsl:for-each>
	</xsl:template>
	<xsl:template name="get_params_without_type">
		<xsl:for-each select="column"><xsl:if test="position() != 1">, </xsl:if>param<xsl:value-of select="@param_name"/></xsl:for-each>
	</xsl:template>
	<!-- 
	<xsl:template name="get_sql_params">
		<xsl:for-each select="column">AND  <xsl:value-of select="@name"/> = ? </xsl:for-each>
	</xsl:template>
	-->
	<xsl:template name="get_sql_params">
		<xsl:for-each select="column">AND  <xsl:value-of select="@name"/> <xsl:value-of select="@condition" disable-output-escaping="yes"/> <xsl:choose>
			<xsl:when test="@omitted = 'false'">
				<xsl:choose>
					<xsl:when test="@type = 'java.lang.String'">"<xsl:value-of select="@value"/>"</xsl:when>
					<xsl:otherwise><xsl:value-of select="@value"/></xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise> ? </xsl:otherwise>
		</xsl:choose></xsl:for-each>
	</xsl:template>
	<xsl:template name="get_fetch_params">
		<xsl:for-each select="column[@omitted='true']">,  param<xsl:value-of select="@param_name"/></xsl:for-each>
	</xsl:template>
	
<!--
//
// Updates
//
-->
	<xsl:template name="update">
	<xsl:variable name="param_type">DB<xsl:value-of select="../bean/@name"/>Bean</xsl:variable>
	public int update<xsl:value-of select="@name"/>(<xsl:value-of select="$param_type"/> bean<xsl:call-template name="get_params_for_update"/>) throws SQLException, IllegalArgumentException, IllegalAccessException {
		setNames();
		 Map&lt;String, Object&gt; map = dataMapper.mapToRow(bean);
		 Map&lt;String, Object&gt; keys = new HashMap&lt;String, Object&gt;();
		 <xsl:for-each select="column">
		 keys.put("<xsl:value-of select="@name"/>", <xsl:choose>
			<xsl:when test="@omitted = 'false'">
				<xsl:choose>
					<xsl:when test="@type = 'java.lang.String'">"<xsl:value-of select="@value"/>"</xsl:when>
					<xsl:otherwise><xsl:value-of select="@value"/></xsl:otherwise>
				</xsl:choose>
				</xsl:when>
				<xsl:otherwise> param<xsl:value-of select="@param_name"/> </xsl:otherwise>
			</xsl:choose>);
		 </xsl:for-each>
		return getConnection().updateRow("<xsl:value-of select="../@name"/>", map, keys);
	}
	</xsl:template>

<!--
//
// Deletes
//
-->
	<xsl:template name="delete">
	public int delete<xsl:value-of select="@name"/>(<xsl:call-template name="get_params"/>) throws SQLException {
		setNames();
		String sql = "DELETE FROM " + tablename + " WHERE  1=1 <xsl:call-template name="get_sql_params"/> ";
		return getConnection().query(sql<xsl:for-each select="column">, param<xsl:value-of select="@param_name"/></xsl:for-each>);
	}
	</xsl:template>
	
<!--
//
// Common queries
//
-->
	<xsl:template name="query">
	<xsl:variable name="ret_type">
		<xsl:choose>
			<xsl:when test="@prefix != 'get'">int</xsl:when>
			<xsl:when test="@is_single = 'true' and string-length(@use) != 0">DB<xsl:value-of select="@use"/>Bean</xsl:when>
			<xsl:when test="string-length(@use) != 0">List&lt;DB<xsl:value-of select="@use"/>Bean&gt;</xsl:when>
			<xsl:when test="@is_single = 'true'">DB<xsl:value-of select="@name"/>Bean</xsl:when>
			<xsl:otherwise>List&lt;DB<xsl:value-of select="@name"/>Bean&gt;</xsl:otherwise>
		</xsl:choose>
	</xsl:variable>
	<xsl:variable name="int_type">DB<xsl:value-of select="@name"/>Bean</xsl:variable>
	<xsl:variable name="new_type">
		<xsl:choose>
			<xsl:when test="@is_single = 'true'"><xsl:value-of select="$ret_type"/></xsl:when>
			<xsl:otherwise>Array<xsl:value-of select="$ret_type"/></xsl:otherwise>
		</xsl:choose>
	</xsl:variable>
	<xsl:variable name="use_name">
		<xsl:choose>
			<xsl:when test="string-length(@use) != 0 and contains(@use, '.') = false"><xsl:value-of select="@use"/></xsl:when>
			<xsl:when test="string-length(@use) = 0"><xsl:value-of select="@name"/></xsl:when>
		</xsl:choose>
	</xsl:variable>
	public <xsl:value-of select="$ret_type"/><xsl:text> </xsl:text><xsl:value-of select="@prefix"/><xsl:value-of select="@name"/>(<xsl:call-template name="get_query_params"/><xsl:if test="string-length(@intruder) != 0"><xsl:if test="count(parameter) != 0">, </xsl:if><xsl:value-of select="@intruder"/> paramIntruder</xsl:if>) throws SQLException, IllegalArgumentException, IllegalAccessException, InstantiationException {
		setNames();
		SqlInjectorInterface injector = new EmptySqlInjector();
		<xsl:if test="string-length(@intruder) != 0">
		if (paramIntruder != null) {
			injector = paramIntruder;
		}
		</xsl:if>
		
		String query = injector.getFullQuery();
		if (query == null) {
			String record = injector.getRecordQuery();
			String from = injector.getFromQuery();
			String join = injector.getJoinQuery();
			String where = injector.getWhereQuery();
			String order = injector.getOrderQuery();
			String limit = injector.getLimitQuery();
			query = "<xsl:apply-templates select="sql"/>";
		}

		<xsl:choose>
			<xsl:when test="@prefix != 'get'">
		int ret = getConnection().query(query<xsl:call-template name="get_query_internal_params"/>);
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="in_class">
					<xsl:choose>
						<xsl:when test="string-length(@use) != 0">DB<xsl:value-of select="@use"/>Bean</xsl:when>
						<xsl:otherwise>DB<xsl:value-of select="@name"/>Bean</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
		List&lt;Map&lt;String, Object&gt;&gt; result = getConnection().fetchRows(tablename + ".get<xsl:value-of select="@name"/>", query <xsl:call-template name="get_query_internal_params"/>);
		<xsl:value-of select="$ret_type"/> ret = null;
		if (result != null) {
					ret = new <xsl:value-of select="$new_type"/>();
				<xsl:choose>
					<xsl:when test="@is_single = 'true'">
					ret = dataMapper.mapFromRow(result.get(0), <xsl:value-of select="$ret_type"/>.class);
					<xsl:if test="/access_info/table/bean[@name=$use_name]/method[@name='onLoad']">ret.onLoad();</xsl:if>										
					</xsl:when>
					<xsl:otherwise>
			for (Map&lt;String, Object&gt; res : result) {
				<xsl:value-of select="$in_class"/> bean = dataMapper.mapFromRow(res, <xsl:value-of select="$in_class"/>.class);
				<xsl:if test="/access_info/table/bean[@name=$use_name]/method[@name='onLoad']">bean.onLoad();</xsl:if>										
				ret.add(bean);
			}
					</xsl:otherwise>
				</xsl:choose>
		}
			</xsl:otherwise>
		</xsl:choose>
		return ret;
	}
	</xsl:template>
<!--
//
// SQL template
//
-->
	<xsl:template match="sql">
		<xsl:for-each select="*|text()">
			<xsl:choose>
				<xsl:when test="name()='record'">" + record + "</xsl:when>
				<xsl:when test="name()='join'">" + join + "</xsl:when>
				<xsl:when test="name()='where'">" + where + "</xsl:when>
				<xsl:when test="name()='limit'">" + limit + "</xsl:when>
				<xsl:when test="name()='order'">" + order + "</xsl:when>
				<xsl:when test="name()='from'">" + from + "</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="translate(., '&#10;&#13;', '  ')" disable-output-escaping="yes"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
	</xsl:template>

<!--
//
// Query Parameters
//
-->
	<xsl:template name="get_query_params">
		<xsl:for-each select="parameter"><xsl:if test="position() != 1">, </xsl:if><xsl:value-of select="@class"/> param<xsl:value-of select="@name"/></xsl:for-each>
	</xsl:template>

	<xsl:template name="get_query_internal_params">
		<xsl:for-each select="parameter">,  param<xsl:value-of select="@name"/></xsl:for-each>
	</xsl:template>
	
</xsl:stylesheet>
